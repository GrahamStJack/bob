Identification
==============

Bottom-up-build (bub) is a build tool intended primarily to facilitate the
development of large C/C++/D projects by:
* Being easy to use.
* Enforcing rules like dependency management.
* Executing tests within the build.
* Supporting code generation.

Some relatively minor but useful additional features are:
* Building outside the source tree.
* Support for using source from multiple repositories.
* Auto-deleting redundant files from the build directory.
  This one is surprisingly useful, because you can't get false success
  from a file left over from an earlier version.

This file provides an introduction into how to use bub. Refer to the example
directory for a simple worked example.


Quick Start
===========

Build bub initially with make from this directory, and put bub and bub-config
on your path.

Set up build directories for the two examples:

bub-config --mode=release ~/builds/bub
cd example
bub-config --mode=debug ~/builds/bub-example

build with:

cd ~/builds/example
bub


The example directory contains a simple example that shows off some of
bub's features.

Bub itself serves as a trivial example, doing just the basics. It may be
a better starting point if you have a very small project.


History
=======

Bub was initially developed to help tame the complexity in a large C++
project.

The complexity of the build system itself is taken care of by
having bub provide the facilities that you actually need, rather than low
level building blocks. Maintaining the configuration of a bub build system
is very easy and simple.

Bub mitigates the complexity of your project by forcing you to pay
attention to dependencies, which has the effect of breaking your design up
into well-defined packages, with dependencies flowing in one direction only.

Benefits of this include:
* The lowest-level code can be implemented and tested independently of
  the code that uses it. This opens the door to cost-effective code reuse.
* Later on, a breakage in the code you are working on is detected very early
  in the build because test code is built and run early, as it doesn't need
  to depend on high-level code.
* Well-factored designs with well-defined non-circular dependencies are way
  easier to understand and maintain than code with dependencies running wild.

As the original C++ project grew, more challenges emperged.

The first was the need to generate source code from things like IDL files.
This is trickier than it appears, because the normal practice of scanning
source files for includes at the start of the build doesn't work for generated
code, which might not even exist at that time. Bub supports code generation,
and importantly defers building a file until all of the generated source files
it could depend on are up to date.

The second problem was that manually keeping track of which libraries to link
with rapidly becomes untenable as the project grows. The usual approach of
having a very small number of libraries and deferring linking of executables
till near the end of the build wasn't acceptable because it defeats bub's
central purpose by having executables that depend on everything. Bub deals
with this as follows:
* When specifying libraries, the public and private header files of that
  library are declared.
* An object file dependency on a public header from a library establishes
  a dependency on that library.
This approach results in a massive simplification in maintenance of a
project's build system, and also provides bub with the information it needs
to enforce dependency rules without relying on the compiler to do it via
-I directives. Dependency violations are thus detected very early, and result
in clear error messages.

The next challenge was that a large C/C++ project wears you down after a while,
and you really want to use a modern, high-productivity language (like D).
Bub was extended to support the D language. The main consequence of this
for C/C++ code is that the headers and bodies comprising a package all have
to be in the same directory. Because by this time bub enforced dependency
rules directly, there is no longer any benefit in putting public headers in
a separate directory, so this doesn't present a problem.
Bub's support for D faclitates the gradual insinuation of D into the code base,
starting with scripts, utilities and tests, and later with production code.


Preparation
===========

Bub assumes that all the source code and external libraries/utilities you will
need are already present. It is up to you to make this happen.

Typically you will have:
* Source code in one or more repository clones or checkouts.
* A number of required third-party packages installed in the system.
* A number of required third-party packages or in-house packages installed
  in non-standard locations.


Configuration
=============

The bub-config utility establishes a build directory, from which bub can build
your project. bub-config requires a configuration file that defines a number of
variables - see example/bub.cfg for a fully documented example.

The configured variables ultimately specify the commands used to build files.
These commands can also write dependencies to a deps file, and this information is
used later to decide if the built file needs to be rebuilt, and aso to determine
what in-project libraries to link with.

The build directory you specify should be outside the source-code repositories,
avoiding pollution of your repositories with build artifacts, and allowing
multiple build directories to be using the same source. For example,
your repository might be in ~/source/myproject, and you might have build
directories ~/build/myproject/debug, ~/build/myproject/profile,
~/build/myproject/release.

The build directory has links back to the source.

A typical repository directory structure is:

repo-root
  assorted-uninteresting-files
  assorted-uninteresting-dirs
  source-root
    bub.cfg
    assorted-source-dirs

To configure a build directory from a repo that looks like the above:

cd repo-root/source-root
bub-config --mode=debug ~/build/myproject/debug


The build directory contains:

environment - Sourced to set up environment variables.
run         - Script to run a project executable.
Buboptions  - Contains variables from config file.
src
  symlinks-to-source-dirs
obj
  dirs-matching-source-dir-tree
    intermediate-build-artifacts
tmp
  assorted temporary files
priv
  dirs-matching-source-dir-tree
    private-finished-build-artifacts
dist
  lib  - Contains public static libraries and all dynamic libraries.
  bin  - Contains executables and scripts.
  data - Contains data files.
  src  - contains public source files from public static libraries.


Building
========

Bub is the build tool. It always builds the whole project, so there is no build
target to specify on the command-line. This isn't a problem because:
* Bub determines what needs to be done quickly.
* Bub's log output is very clean.
* Bub builds files (mostly) in definition order, and stops the build when an error
  occurs, so you quickly get back to the point of failure during development.
* Bub runs and evaluates unit tests (mostly) in definition order, so if you have
  unit tests, you quickly get to the point of failure during debugging.

The "mostly" above refers to the jitter in build order that occurs when building
with multiple cores.

The build process is controlled by Bubfiles. The top-level Bubfile is generated,
and has a "contain" rule that brings in all the top level packages specified in
the config file.

Refer to the example's Bubfiles.

Bubfile syntax is:

# This line is a comment.
<statement-type> <param0> [: <param1> [: param2 [: param3]]];

where a parameter is a space-separated list of tokens.


Statement types are:


Contain
-------

contain subdir-names [: protected];

eg: contain math net stream tools;

Specifies that the listed subdirectories contain Bubfiles and are included in
the build. Visibility defaults to public. Contained directories must be
specified in dependency order (lowest level first).


Static Lib
----------

static-lib lib-name : public-source : protected-source [: required-sys-libs];
public-lib lib-name : public-source : protected-source [: required-sys-libs];

eg: static-lib math : matrix.h alg.h : matrix.cpp alg.cpp : m;

The order of the listed files should be in dependency order, but that is only
required if some of the library's source files are generated within the library.

A static lib has to contain at least one object file generated from the listed
source files.

The sys-libs should be listed in dependency order (lowest level first).
Only sys-libs not already pulled in by other dependencies need by listed.
For example, some higher-level library that depends on math doesn't need to
specify that it requires sys-lib m.

Specifies a static library. All the source files should be in the same language,
or in a language from which the library's language files can be generated.
Exceptions:
* .c files can mix with others.
* Files without configured build commands (eg header files) can mix with others.

The public files are those that client code can import/include.

public-lib is identical to static-lib except that:

* The public source files are copied into dist/src/<trail>

* If the library is not contained in a dynamic library, the library file is
  copied into dist/lib.


Dynamic Lib
-----------

dynamic-lib name : static-libs;

eg: dynamic-lib tools : tools;

Dynamic libs contain all the object files contained in the specified static libs.
Executables defined after a dynamic library will link to the dynamic library
rather than the static library.

The order of the specified static libs is unimportant.

The contained static-libs all have to be declared in the current Bubfile
or in a transitively contained directory's Bubfile.
The last path element can optionally be omitted if it is the same as the
containing directory name, which is often the case.

For example, if the directory structure is:
  one - defines dynamic library "one"
    two - defines static library "two"
    three - defines static library "three"
then the statement in one's Bubfile to generate the dynamic library is:

dynamic-lib one : two three;

or, if you want to do it in full, which you must if the names don't match:

dynamic-lib one : two/two three/three;

Note that a directory can contain any number of static and dynamic directories.


Executable
----------

dist-exe exe-name : source [: required-sys-libs];
test-exe exe-name : source [: required-sys-libs];
priv-exe exe-name : source [: required-sys-libs];

eg: test-exe math-test : math_test.cpp;

As with static libraries, only sys-libs not already pulled in by other
dependencies need by listed. Any that are present should be in dependency
order (lowest level first).

dist-exe places the built executable in the dist/bin directory.

priv-exe places the build executable in the priv/<trail> directory.

test-exe places the built executable in the priv/<trail> directory,
and executes the test when its result file is out of date.

The test is run with a command-line argument --tmp=<path>, where
<path> is a temporary directory that the test can use for scratch files
if necessary. The temporary directory is deleted if the test passes.


Scripts, data and docs
----------------------

misc names [: dist-destination-path]

Copies or (if there is a rule to generate files from the extension)
generates files that do not contribute to libraries or executables.
If any of names is a directory, it is recursed into.

For example:

# copy/build specified files into dist/bin
misc foo.sh foo2.sh : dist/bin;

# copy/build index.rst into priv/<chain> and files in doc dir and below
# into priv/<chain>/doc, preserving any subdirectory structure.
misc index.rst doc;

Source files can be generated this way too, but they are usually generated
via a static-lib statement.


Dependencies
============

Discussion
----------

Dependencies are a major preoccupation of bub. This is because on large
projects, management of dependencies is essential, and the best way to manage
something is with a tool. If you can't build software that breaks the rules,
you can't sneak an invalid dependency in while no-one is looking.


Rules
-----

Dependencies are deduced from information in generated dependency files via
using ${DEPS} in commands, and also from containment/dependency information
in Bubfiles.

File A is allowed to depend on file B if all of the following are true:

* A is defined later than B, or B is a descendant of A.

* A's package is not a descendant of B's package (both in the same package is ok).  

* B is visible.


Visibility works like this:

* The protected source files in a static lib can only be depended on by that
  static lib's object files.

* All of the source files in an exe can only be depended on by that exe's
  object files.

* Packages can be public or protected. Files that are descendants of
  protected package A are only visible to files that are descendants of
  A's parent package.


An object file can only be used once - either in a library or an executable.
Dynamic libraries don't count as a use - they are just a repackaging.

A dynamic library cannot contain the same static library as another dynamic library.

All static libraries referred to by the static libraries in a dynamic library
must also be packaged in dynamic libraries.

All static libraries referred to by public static libraries must also be public.
